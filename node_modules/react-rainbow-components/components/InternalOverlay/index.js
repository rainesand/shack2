"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactDom = require("react-dom");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _ContentMetaResolver = _interopRequireDefault(require("./ContentMetaResolver"));

var _defaultPositionResolver = _interopRequireDefault(require("./helpers/defaultPositionResolver"));

var _scrollController = require("../../libs/scrollController");

function _templateObject() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n    position: fixed;\n    z-index: 999999999;\n    top: ", "px;\n    left: ", "px;\n    ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var Container = _styledComponents["default"].div(_templateObject(), function (props) {
  return props.position && props.position.top;
}, function (props) {
  return props.position && props.position.left;
}, function (props) {
  return props.position && props.position.width && "\n            width: ".concat(props.position.width, "px;\n        ");
});

var resolveElement = function resolveElement(ref) {
  if (typeof ref === 'function') {
    var ret = ref();
    return ret && ret.current;
  }

  return ref && ref.current;
};

var resolveTriggerMeta = function resolveTriggerMeta(ref) {
  var element = resolveElement(ref);

  if (element instanceof Element) {
    var _element$getClientRec = element.getClientRects()[0],
        x = _element$getClientRec.x,
        y = _element$getClientRec.y,
        width = _element$getClientRec.width,
        height = _element$getClientRec.height;
    return {
      leftUpAnchor: {
        x: x,
        y: y
      },
      leftBottomAnchor: {
        x: x,
        y: y + height
      },
      rightUpAnchor: {
        x: x + width,
        y: y
      },
      rightBottomAnchor: {
        x: x + width,
        y: y + height
      },
      width: width,
      height: height
    };
  } // eslint-disable-next-line no-console


  console.debug("The \"triggerElementRef\" provided is not resolving to a valid DOM Element.");
  return {
    leftUpAnchor: {
      x: 0,
      y: 0
    },
    leftBottomAnchor: {
      x: 0,
      y: 0
    },
    rightUpAnchor: {
      x: 0,
      y: 0
    },
    rightBottomAnchor: {
      x: 0,
      y: 0
    },
    width: 0,
    height: 0
  };
};

var resolveViewportMeta = function resolveViewportMeta() {
  return {
    width: window.innerWidth,
    height: window.innerHeight
  };
};

var resolvePosition = function resolvePosition(opts) {
  var triggerMeta = opts.triggerMeta,
      viewportMeta = opts.viewportMeta,
      contentMeta = opts.contentMeta,
      positionResolver = opts.positionResolver;

  if (typeof positionResolver === 'function') {
    var pos = positionResolver({
      trigger: triggerMeta,
      viewport: viewportMeta,
      content: contentMeta
    });

    if ((0, _typeof2["default"])(pos) === 'object') {
      return pos;
    }
  }

  return (0, _defaultPositionResolver["default"])({
    trigger: triggerMeta,
    viewport: viewportMeta,
    content: contentMeta
  });
};
/**
 * This component implements the positioning of a component (inserted in the DOM at the body level) based on a trigger DOM element. By the way of example, you can think of the use case of a Menu Options, Tooltip, Popup that should be floating on top of all the elements and it should be correctly positioned based on the component/element that triggers the show/open action.
 * @category Internal
 */


var InternalOverlay = function InternalOverlay(props) {
  var ContentComponent = props.render,
      isVisible = props.isVisible,
      triggerElementRef = props.triggerElementRef,
      positionResolver = props.positionResolver,
      onOpened = props.onOpened,
      children = props.children;

  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      contentMeta = _useState2[0],
      updateContentMeta = _useState2[1];

  (0, _react.useEffect)(function () {
    if (isVisible && contentMeta) {
      onOpened();
      (0, _scrollController.disableBodyScroll)(undefined, {
        reserveScrollBarGap: true
      });
    }

    return function () {
      (0, _scrollController.enableBodyScroll)();
    };
  }, [isVisible, contentMeta, onOpened]);

  if (isVisible) {
    var content = children || _react["default"].createElement(ContentComponent, null);

    if (contentMeta) {
      var triggerMeta = resolveTriggerMeta(triggerElementRef);
      var viewportMeta = resolveViewportMeta();
      var position = resolvePosition({
        triggerMeta: triggerMeta,
        contentMeta: contentMeta,
        viewportMeta: viewportMeta,
        positionResolver: positionResolver
      });
      return (0, _reactDom.createPortal)(_react["default"].createElement(Container, {
        position: position
      }, content), document.body);
    }

    return _react["default"].createElement(_ContentMetaResolver["default"], {
      component: ContentComponent,
      onResolved: updateContentMeta
    }, children);
  }

  return null;
};

InternalOverlay.propTypes = {
  /** Functional component or class that will be rendered when the isVisible prop is true. */
  render: _propTypes["default"].func,

  /** Controls whether the InternalOverlay is visible or not. If true, the content of the Overlay is shown. */
  isVisible: _propTypes["default"].bool,

  /** Ref or function that returns a ref to a DOM element, the DOM element resolved by this ref will be used to positioning the component passed when visible. */
  triggerElementRef: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]).isRequired,

  /** It could be used to write your own position resolution. The function passed here will receive the necessary data to compute an object with { top, left } CSS position of the component rendered. */
  positionResolver: _propTypes["default"].func,

  /** A callback triggered when the overlay component is opened. This is useful for example to set focus
   * to an element after it is opened.
   */
  onOpened: _propTypes["default"].func,

  /**
   * @ignore
   */
  children: _propTypes["default"].node
};
InternalOverlay.defaultProps = {
  render: function render() {},
  isVisible: false,
  positionResolver: undefined,
  onOpened: function onOpened() {},
  children: undefined
};
InternalOverlay.defaultPositionResolver = _defaultPositionResolver["default"];
var _default = InternalOverlay;
exports["default"] = _default;